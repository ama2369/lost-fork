from __future__ import annotations
import sys
import os
import click
import atexit
import psycopg
import lxml.objectify
import lxml.etree
import uuid
import base64
from psycopg_pool import ConnectionPool
from psycopg.adapt import Loader, Dumper
from datetime import datetime, timedelta
from lxml.etree import Element, SubElement, XML
from collections import namedtuple
from abc import ABC, abstractmethod
from flask import Flask, request, abort, Response
from werkzeug.exceptions import BadRequest, NotFound
from flask_cors import CORS


MIME_TYPE      = 'application/lost+xml'
LOST_NAMESPACE = 'urn:ietf:params:xml:ns:lost1'
GML_NAMESPACE  = 'http://www.opengis.net/gml'
XML_NAMESPACE  = 'http://www.w3.org/XML/1998/namespace'
NAMESPACE_MAP  = {
    None: LOST_NAMESPACE,
    'gml': GML_NAMESPACE,
    'xml': XML_NAMESPACE
}


# Create a pool of persistent PostgreSQL database connections. When we are done
# with a PostgreSQL connection, we simply return it to the pool without closing
# the connection. This helps avoid the need to open a new database connection
# for every request.
pool: ConnectionPool


# Instances of LoST servers for various coodinate systems, e.g., geodetic-2d and
# civic.
lost_server: dict[str, LoSTServer] = dict()


class GUID:
    '''A globally unique identifier.

    A custom implementation of a globally unique identifier. Backed by UUID
    version 4 (randomly generated) with a base64 string representation.
    '''
    def __init__(self, *args):
        if len(args) == 0:
            self.value = uuid.uuid4()
        elif len(args) == 1:
            v = args[0]
            if v is None:
                self.value = uuid.uuid4()
            if isinstance(v, uuid.UUID):
                self.value = v
            elif isinstance(v, GUID):
                self.value = v.value
            elif isinstance(v, str):
                if len(v) == 22:
                    self.value = uuid.UUID(bytes=base64.urlsafe_b64decode(f'{v}=='), version=4)
                else:
                    self.value = uuid.UUID('{%s}' % v)
            else:
                raise Exception("Unsupported GUID value representation")
        else:
            raise Exception("Unsupported number of GUID parameters")

    def __str__(self):
        return base64.urlsafe_b64encode(self.value.bytes)[:-2].decode('ascii')

    def __eq__(self, obj):
        return self.value == obj.value


def adapt_for_guid(con: psycopg.Connection):
    class GUIDLoader(Loader):
        def load(self, data):
            return GUID(str(data, 'ascii'))


    class GUIDDumper(Dumper):
        oid = psycopg.adapters.types["uuid"].oid

        def dump(self, data):
            return f"{data.value}".encode('ascii')

    con.adapters.register_loader('uuid', GUIDLoader)
    con.adapters.register_dumper(GUID, GUIDDumper)


# The order of coordinate axes across various standards is as follows:
# GeoJSON:            [lon, lat]
# PostGIS (WKT, WKB): [lon, lat]
# KML:                [lon, lat]
# EPSG:4326           [lat, lon]
# GML:                [lat, lon]
Point = namedtuple('Point', ['lon', 'lat'])


class LoSTServer(ABC):
    '''An abstract LoST server base class

    This class is not meant to be instantiated directly. It just provides an
    interface that all address-type-specific LoST server implementations must
    provide.

    Instantiate GeographicLoSTServer or CivicLostServer instead.
    '''
    def __init__(self, server_id, table):
        self.server_id = server_id
        self.table = table

    @abstractmethod
    def find_service(self, req: lxml.objectify.ObjectifiedElement):
        pass


def service_boundary(value: str, gml_ns=GML_NAMESPACE, profile="geodetic-2d"):
    '''Convert ST_AsGML output to a service boundary object

    This function constructs a serviceBoundary XML element tree from the output
    generated by PostGIS' ST_AsGML function. ST_AsGML should be configured to
    generate GML version 3 using the standard namespace prefix "gml", for
    example: ST_AsGML(3, shape, 5, 17)

    Since ST_AsGML does not declare the gml namespace, we need to create a new
    root element here and declare the namespace there. Otherwise, lxml would not
    be able to parse the output of ST_AsGML.
    '''

    parser = lxml.etree.XMLParser(remove_blank_text=True)
    return XML(f'''
        <serviceBoundary profile="{profile}" xmlns:gml="{gml_ns}">
            {value}
        </serviceBoundary>''', parser)


class GeographicLoSTServer(LoSTServer):
    def find_point(self, service, point: Point):
        with pool.connection() as con:
            cur = con.execute('''
                SELECT m.id, m.service, m.modified, m.attrs, ST_AsGML(3, s.geometries, 5, 17)
                FROM   mapping AS m JOIN shape AS s ON m.shape=s.id
                WHERE  ST_Contains(s.geometries, ST_GeomFromText(%s, 4326))
                    and m.service = %s''',
                (f'Point({point.lon} {point.lat})', service))

            row = cur.fetchone()

        if row is None:
            raise NotFound()

        id, service, modified, attrs, shape = row

        res = Element(f'{{{LOST_NAMESPACE}}}findServiceResponse', nsmap=NAMESPACE_MAP)
        mapping = SubElement(res, 'mapping',
            source=self.server_id,
            sourceId=str(id),
            lastUpdated=modified.isoformat(),
            expires=(datetime.now() + timedelta(days=1)).isoformat())

        if 'displayName' in attrs:
            dn = SubElement(mapping, 'displayName')
            dn.set(f'{{{XML_NAMESPACE}}}lang', 'en')
            dn.text = attrs['displayName']

        SubElement(mapping, 'service').text = service
        mapping.append(service_boundary(shape))

        for uri in attrs.get('uri', []):
            SubElement(mapping, 'uri').text = uri

        return res

    def find_service(self, req: lxml.objectify.ObjectifiedElement):
        service = req.service.text
        if service is not None:
            service = service.strip()

        geom = req.location.getchildren()[0]
        if geom.tag == f'{{{GML_NAMESPACE}}}Point':
            lat, lon = (geom.pos.text or '').strip().split()
            return self.find_point(service, Point(lon, lat))
        else:
            raise BadRequest('Unsupported geometry type')


class CivicLoSTServer(LoSTServer):
    def find_service(self, doc):
        pass


app = Flask(__name__)
CORS(app)


@app.route("/", methods=["GET"])
def ping():
    with pool.connection() as con:
        res = con.execute("SELECT NOW()").fetchone()
        assert res is not None
        return f"Database says: {res[0]}"


@app.route("/", methods=["POST"])
def submit():
    if request.mimetype != MIME_TYPE:
        abort(400, 'Unsupported content type')

    req = lxml.objectify.fromstring(request.data)

    if req.tag == f"{{{LOST_NAMESPACE}}}findService":
        profile = req.location.attrib['profile']
        try:
            server = lost_server[profile]
        except KeyError:
            abort(400, f"Unsupported location profile '{profile}'")

        res = server.find_service(req)
        lxml.objectify.deannotate(res, cleanup_namespaces=True, xsi_nil=True)
        return Response(lxml.etree.tostring(res, encoding='UTF-8',
            pretty_print=True, xml_declaration=True), mimetype=MIME_TYPE)
    else:
        abort(400, f'Unsupported request type "{req.tag}"')


@click.group(invoke_without_command=True)
@click.pass_context
def cli(ctx):
    try:
        if ctx.invoked_subcommand is None:
            ctx.invoke(start)
    except KeyboardInterrupt:
        pass
    pass


@cli.command()
@click.option('--port', '-p', type=int, help='Port number to listen on.')
@click.option('--db-url', '-d', help='PostgreSQL database URL')
@click.option('--max-con', default=16, help='Maximum number of DB connections', show_default=True)
@click.option('--min-con', default=1, help='Minimum number of free DB connections', show_default=True)
@click.option('--geo-table', default='geo', help='Name of geographic mapping table', show_default=True)
@click.option('--civic-table', default='civic', help='Name of civic address mapping table', show_default=True)
@click.option('--server-id', default='lost-server', help='Unique ID of the LoST server', show_default=True)
def start(port, db_url, max_con, min_con, geo_table, civic_table, server_id):
    global pool, lost_server

    if db_url is None:
        try:
            db_url = os.environ['DB_URL']
        except KeyError:
            print("Error: Please configure database via --db-url or environment variable DB_URL")
            sys.exit(1)

    try:
        pool = ConnectionPool(db_url, min_size=min_con, max_size=max_con, num_workers=1, kwargs={
            'autocommit': True
        }, configure=adapt_for_guid)
        atexit.register(lambda: pool.close())
        # Wait for the connection pool to create its first connections. We want
        # to fail early if the database cannot be connected for some reason.
        pool.wait()
    except Exception as e:
        print(f"Error while connecting to datababase '{db_url}': {e}")
        sys.exit(1)

    if port is None:
        port = int(os.environ.get("PORT", 5000))

    if geo_table != None:
        print("Instantiating a LoST server for the 'geodetic-2d' profile")
        lost_server['geodetic-2d'] = GeographicLoSTServer(server_id, geo_table)

    if civic_table != None:
        print("Instantiating a LoST server for the 'civic' profile")
        lost_server['civic'] = CivicLoSTServer(server_id, civic_table)

    app.run('0.0.0.0', port, debug=True, threaded=True)


@cli.command('init-db')
@click.option('--db-url', '-d', help='PostgreSQL database URL')
@click.option('--drop', '-D', default=False, is_flag=True, help='Drop tables if they exist first')
def init_db(db_url, drop):
    if db_url is None:
        try:
            db_url = os.environ['DB_URL']
        except KeyError:
            print("Error: Please configure database via --db-url or environment variable DB_URL")
            sys.exit(1)

    with psycopg.connect(db_url, autocommit=True) as con:
        if drop:
            print("Dropping modification trigger on table mapping")
            con.execute('DROP TRIGGER IF EXISTS update_modification_timestamp ON mapping')

            print("Dropping table mappping")
            con.execute('DROP TABLE IF EXISTS mapping')

            print("Dropping function update_modification_timestamp()")
            con.execute('DROP FUNCTION IF EXISTS update_modification_timestamp()')

        print("Creating function update_modification_timestamp()")
        con.execute('''
            CREATE FUNCTION public.update_modification_timestamp() RETURNS trigger
                LANGUAGE plpgsql
                AS $$
            begin
                NEW.modified = now();
                return NEW;
            end;
            $$;
        ''')

        print("Creating table mapping")
        con.execute('''
            CREATE TABLE mapping (
                id       uuid         PRIMARY KEY DEFAULT uuid_generate_v4(),
                service  text         NOT NULL,
                shape    uuid         references shape(id) ON DELETE SET NULL,
                created  timestamptz  DEFAULT now() NOT NULL,
                modified timestamptz  DEFAULT now() NOT NULL,
                attrs    jsonb        NOT NULL DEFAULT '{}'::jsonb
            )''')

        print("Creating modification trigger on table mapping")
        con.execute('''
            CREATE TRIGGER update_modification_timestamp BEFORE UPDATE ON mapping FOR EACH ROW EXECUTE FUNCTION public.update_modification_timestamp();
        ''')


if __name__ == '__main__':
    cli()